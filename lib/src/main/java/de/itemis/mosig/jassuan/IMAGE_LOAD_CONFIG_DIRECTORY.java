// Generated by jextract

package de.itemis.mosig.jassuan;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.CLinker.*;
public class IMAGE_LOAD_CONFIG_DIRECTORY {

    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(
        C_LONG.withName("Size"),
        C_LONG.withName("TimeDateStamp"),
        C_SHORT.withName("MajorVersion"),
        C_SHORT.withName("MinorVersion"),
        C_LONG.withName("GlobalFlagsClear"),
        C_LONG.withName("GlobalFlagsSet"),
        C_LONG.withName("CriticalSectionDefaultTimeout"),
        C_LONG_LONG.withName("DeCommitFreeBlockThreshold"),
        C_LONG_LONG.withName("DeCommitTotalFreeThreshold"),
        C_LONG_LONG.withName("LockPrefixTable"),
        C_LONG_LONG.withName("MaximumAllocationSize"),
        C_LONG_LONG.withName("VirtualMemoryThreshold"),
        C_LONG_LONG.withName("ProcessAffinityMask"),
        C_LONG.withName("ProcessHeapFlags"),
        C_SHORT.withName("CSDVersion"),
        C_SHORT.withName("Reserved1"),
        C_LONG_LONG.withName("EditList"),
        C_LONG_LONG.withName("SecurityCookie"),
        C_LONG_LONG.withName("SEHandlerTable"),
        C_LONG_LONG.withName("SEHandlerCount")
    );
    public static MemoryLayout $LAYOUT() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.$struct$LAYOUT;
    }
    static final VarHandle Size$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement("Size"));
    public static VarHandle Size$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.Size$VH;
    }
    public static int Size$get(MemorySegment seg) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.Size$VH.get(seg);
    }
    public static void Size$set( MemorySegment seg, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.Size$VH.set(seg, x);
    }
    public static int Size$get(MemorySegment seg, long index) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.Size$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Size$set(MemorySegment seg, long index, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.Size$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle TimeDateStamp$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement("TimeDateStamp"));
    public static VarHandle TimeDateStamp$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.TimeDateStamp$VH;
    }
    public static int TimeDateStamp$get(MemorySegment seg) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.TimeDateStamp$VH.get(seg);
    }
    public static void TimeDateStamp$set( MemorySegment seg, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.TimeDateStamp$VH.set(seg, x);
    }
    public static int TimeDateStamp$get(MemorySegment seg, long index) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.TimeDateStamp$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void TimeDateStamp$set(MemorySegment seg, long index, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.TimeDateStamp$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle MajorVersion$VH = $struct$LAYOUT.varHandle(short.class, MemoryLayout.PathElement.groupElement("MajorVersion"));
    public static VarHandle MajorVersion$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.MajorVersion$VH;
    }
    public static short MajorVersion$get(MemorySegment seg) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.MajorVersion$VH.get(seg);
    }
    public static void MajorVersion$set( MemorySegment seg, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.MajorVersion$VH.set(seg, x);
    }
    public static short MajorVersion$get(MemorySegment seg, long index) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.MajorVersion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MajorVersion$set(MemorySegment seg, long index, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.MajorVersion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle MinorVersion$VH = $struct$LAYOUT.varHandle(short.class, MemoryLayout.PathElement.groupElement("MinorVersion"));
    public static VarHandle MinorVersion$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.MinorVersion$VH;
    }
    public static short MinorVersion$get(MemorySegment seg) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.MinorVersion$VH.get(seg);
    }
    public static void MinorVersion$set( MemorySegment seg, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.MinorVersion$VH.set(seg, x);
    }
    public static short MinorVersion$get(MemorySegment seg, long index) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.MinorVersion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MinorVersion$set(MemorySegment seg, long index, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.MinorVersion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle GlobalFlagsClear$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement("GlobalFlagsClear"));
    public static VarHandle GlobalFlagsClear$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsClear$VH;
    }
    public static int GlobalFlagsClear$get(MemorySegment seg) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsClear$VH.get(seg);
    }
    public static void GlobalFlagsClear$set( MemorySegment seg, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsClear$VH.set(seg, x);
    }
    public static int GlobalFlagsClear$get(MemorySegment seg, long index) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsClear$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GlobalFlagsClear$set(MemorySegment seg, long index, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsClear$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle GlobalFlagsSet$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement("GlobalFlagsSet"));
    public static VarHandle GlobalFlagsSet$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsSet$VH;
    }
    public static int GlobalFlagsSet$get(MemorySegment seg) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsSet$VH.get(seg);
    }
    public static void GlobalFlagsSet$set( MemorySegment seg, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsSet$VH.set(seg, x);
    }
    public static int GlobalFlagsSet$get(MemorySegment seg, long index) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsSet$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GlobalFlagsSet$set(MemorySegment seg, long index, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.GlobalFlagsSet$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle CriticalSectionDefaultTimeout$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement("CriticalSectionDefaultTimeout"));
    public static VarHandle CriticalSectionDefaultTimeout$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.CriticalSectionDefaultTimeout$VH;
    }
    public static int CriticalSectionDefaultTimeout$get(MemorySegment seg) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.CriticalSectionDefaultTimeout$VH.get(seg);
    }
    public static void CriticalSectionDefaultTimeout$set( MemorySegment seg, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.CriticalSectionDefaultTimeout$VH.set(seg, x);
    }
    public static int CriticalSectionDefaultTimeout$get(MemorySegment seg, long index) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.CriticalSectionDefaultTimeout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CriticalSectionDefaultTimeout$set(MemorySegment seg, long index, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.CriticalSectionDefaultTimeout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle DeCommitFreeBlockThreshold$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("DeCommitFreeBlockThreshold"));
    public static VarHandle DeCommitFreeBlockThreshold$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitFreeBlockThreshold$VH;
    }
    public static long DeCommitFreeBlockThreshold$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitFreeBlockThreshold$VH.get(seg);
    }
    public static void DeCommitFreeBlockThreshold$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitFreeBlockThreshold$VH.set(seg, x);
    }
    public static long DeCommitFreeBlockThreshold$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitFreeBlockThreshold$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeCommitFreeBlockThreshold$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitFreeBlockThreshold$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle DeCommitTotalFreeThreshold$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("DeCommitTotalFreeThreshold"));
    public static VarHandle DeCommitTotalFreeThreshold$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitTotalFreeThreshold$VH;
    }
    public static long DeCommitTotalFreeThreshold$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitTotalFreeThreshold$VH.get(seg);
    }
    public static void DeCommitTotalFreeThreshold$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitTotalFreeThreshold$VH.set(seg, x);
    }
    public static long DeCommitTotalFreeThreshold$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitTotalFreeThreshold$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeCommitTotalFreeThreshold$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.DeCommitTotalFreeThreshold$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle LockPrefixTable$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("LockPrefixTable"));
    public static VarHandle LockPrefixTable$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.LockPrefixTable$VH;
    }
    public static long LockPrefixTable$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.LockPrefixTable$VH.get(seg);
    }
    public static void LockPrefixTable$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.LockPrefixTable$VH.set(seg, x);
    }
    public static long LockPrefixTable$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.LockPrefixTable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void LockPrefixTable$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.LockPrefixTable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle MaximumAllocationSize$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("MaximumAllocationSize"));
    public static VarHandle MaximumAllocationSize$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.MaximumAllocationSize$VH;
    }
    public static long MaximumAllocationSize$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.MaximumAllocationSize$VH.get(seg);
    }
    public static void MaximumAllocationSize$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.MaximumAllocationSize$VH.set(seg, x);
    }
    public static long MaximumAllocationSize$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.MaximumAllocationSize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MaximumAllocationSize$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.MaximumAllocationSize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle VirtualMemoryThreshold$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("VirtualMemoryThreshold"));
    public static VarHandle VirtualMemoryThreshold$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.VirtualMemoryThreshold$VH;
    }
    public static long VirtualMemoryThreshold$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.VirtualMemoryThreshold$VH.get(seg);
    }
    public static void VirtualMemoryThreshold$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.VirtualMemoryThreshold$VH.set(seg, x);
    }
    public static long VirtualMemoryThreshold$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.VirtualMemoryThreshold$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void VirtualMemoryThreshold$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.VirtualMemoryThreshold$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle ProcessAffinityMask$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("ProcessAffinityMask"));
    public static VarHandle ProcessAffinityMask$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.ProcessAffinityMask$VH;
    }
    public static long ProcessAffinityMask$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.ProcessAffinityMask$VH.get(seg);
    }
    public static void ProcessAffinityMask$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.ProcessAffinityMask$VH.set(seg, x);
    }
    public static long ProcessAffinityMask$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.ProcessAffinityMask$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ProcessAffinityMask$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.ProcessAffinityMask$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle ProcessHeapFlags$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement("ProcessHeapFlags"));
    public static VarHandle ProcessHeapFlags$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.ProcessHeapFlags$VH;
    }
    public static int ProcessHeapFlags$get(MemorySegment seg) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.ProcessHeapFlags$VH.get(seg);
    }
    public static void ProcessHeapFlags$set( MemorySegment seg, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.ProcessHeapFlags$VH.set(seg, x);
    }
    public static int ProcessHeapFlags$get(MemorySegment seg, long index) {
        return (int)IMAGE_LOAD_CONFIG_DIRECTORY.ProcessHeapFlags$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ProcessHeapFlags$set(MemorySegment seg, long index, int x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.ProcessHeapFlags$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle CSDVersion$VH = $struct$LAYOUT.varHandle(short.class, MemoryLayout.PathElement.groupElement("CSDVersion"));
    public static VarHandle CSDVersion$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.CSDVersion$VH;
    }
    public static short CSDVersion$get(MemorySegment seg) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.CSDVersion$VH.get(seg);
    }
    public static void CSDVersion$set( MemorySegment seg, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.CSDVersion$VH.set(seg, x);
    }
    public static short CSDVersion$get(MemorySegment seg, long index) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.CSDVersion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CSDVersion$set(MemorySegment seg, long index, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.CSDVersion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle Reserved1$VH = $struct$LAYOUT.varHandle(short.class, MemoryLayout.PathElement.groupElement("Reserved1"));
    public static VarHandle Reserved1$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.Reserved1$VH;
    }
    public static short Reserved1$get(MemorySegment seg) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.Reserved1$VH.get(seg);
    }
    public static void Reserved1$set( MemorySegment seg, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.Reserved1$VH.set(seg, x);
    }
    public static short Reserved1$get(MemorySegment seg, long index) {
        return (short)IMAGE_LOAD_CONFIG_DIRECTORY.Reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Reserved1$set(MemorySegment seg, long index, short x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.Reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle EditList$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("EditList"));
    public static VarHandle EditList$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.EditList$VH;
    }
    public static long EditList$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.EditList$VH.get(seg);
    }
    public static void EditList$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.EditList$VH.set(seg, x);
    }
    public static long EditList$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.EditList$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EditList$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.EditList$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle SecurityCookie$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SecurityCookie"));
    public static VarHandle SecurityCookie$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.SecurityCookie$VH;
    }
    public static long SecurityCookie$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.SecurityCookie$VH.get(seg);
    }
    public static void SecurityCookie$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.SecurityCookie$VH.set(seg, x);
    }
    public static long SecurityCookie$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.SecurityCookie$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SecurityCookie$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.SecurityCookie$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle SEHandlerTable$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SEHandlerTable"));
    public static VarHandle SEHandlerTable$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerTable$VH;
    }
    public static long SEHandlerTable$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerTable$VH.get(seg);
    }
    public static void SEHandlerTable$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerTable$VH.set(seg, x);
    }
    public static long SEHandlerTable$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerTable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SEHandlerTable$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerTable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle SEHandlerCount$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SEHandlerCount"));
    public static VarHandle SEHandlerCount$VH() {
        return IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerCount$VH;
    }
    public static long SEHandlerCount$get(MemorySegment seg) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerCount$VH.get(seg);
    }
    public static void SEHandlerCount$set( MemorySegment seg, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerCount$VH.set(seg, x);
    }
    public static long SEHandlerCount$get(MemorySegment seg, long index) {
        return (long)IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerCount$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SEHandlerCount$set(MemorySegment seg, long index, long x) {
        IMAGE_LOAD_CONFIG_DIRECTORY.SEHandlerCount$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.ofScope(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


