// Generated by jextract

package de.itemis.mosig.jassuan;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.CLinker.*;
public class IOleObjectVtbl {

    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(
        C_POINTER.withName("QueryInterface"),
        C_POINTER.withName("AddRef"),
        C_POINTER.withName("Release"),
        C_POINTER.withName("SetClientSite"),
        C_POINTER.withName("GetClientSite"),
        C_POINTER.withName("SetHostNames"),
        C_POINTER.withName("Close"),
        C_POINTER.withName("SetMoniker"),
        C_POINTER.withName("GetMoniker"),
        C_POINTER.withName("InitFromData"),
        C_POINTER.withName("GetClipboardData"),
        C_POINTER.withName("DoVerb"),
        C_POINTER.withName("EnumVerbs"),
        C_POINTER.withName("Update"),
        C_POINTER.withName("IsUpToDate"),
        C_POINTER.withName("GetUserClassID"),
        C_POINTER.withName("GetUserType"),
        C_POINTER.withName("SetExtent"),
        C_POINTER.withName("GetExtent"),
        C_POINTER.withName("Advise"),
        C_POINTER.withName("Unadvise"),
        C_POINTER.withName("EnumAdvise"),
        C_POINTER.withName("GetMiscStatus"),
        C_POINTER.withName("SetColorScheme")
    ).withName("IOleObjectVtbl");
    public static MemoryLayout $LAYOUT() {
        return IOleObjectVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.QueryInterface$FUNC, false
    );
    public interface QueryInterface {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(QueryInterface fi) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IOleObjectVtbl.QueryInterface$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(QueryInterface fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IOleObjectVtbl.QueryInterface$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static QueryInterface ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.QueryInterface$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("QueryInterface")));
    public static VarHandle QueryInterface$VH() {
        return IOleObjectVtbl.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment) {
        return QueryInterface.ofAddress(QueryInterface$get(segment));
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.AddRef$FUNC, false
    );
    public interface AddRef {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(AddRef fi) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IOleObjectVtbl.AddRef$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(AddRef fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IOleObjectVtbl.AddRef$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static AddRef ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)IOleObjectVtbl.AddRef$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("AddRef")));
    public static VarHandle AddRef$VH() {
        return IOleObjectVtbl.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment) {
        return AddRef.ofAddress(AddRef$get(segment));
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.Release$FUNC, false
    );
    public interface Release {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(Release fi) {
            return RuntimeHelper.upcallStub(Release.class, fi, IOleObjectVtbl.Release$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(Release fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(Release.class, fi, IOleObjectVtbl.Release$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static Release ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)IOleObjectVtbl.Release$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("Release")));
    public static VarHandle Release$VH() {
        return IOleObjectVtbl.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment) {
        return Release.ofAddress(Release$get(segment));
    }
    static final FunctionDescriptor SetClientSite$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle SetClientSite$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.SetClientSite$FUNC, false
    );
    public interface SetClientSite {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(SetClientSite fi) {
            return RuntimeHelper.upcallStub(SetClientSite.class, fi, IOleObjectVtbl.SetClientSite$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(SetClientSite fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(SetClientSite.class, fi, IOleObjectVtbl.SetClientSite$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static SetClientSite ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IOleObjectVtbl.SetClientSite$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetClientSite$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SetClientSite")));
    public static VarHandle SetClientSite$VH() {
        return IOleObjectVtbl.SetClientSite$VH;
    }
    public static MemoryAddress SetClientSite$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetClientSite$VH.get(seg);
    }
    public static void SetClientSite$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetClientSite$VH.set(seg, x);
    }
    public static MemoryAddress SetClientSite$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetClientSite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetClientSite$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetClientSite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetClientSite SetClientSite (MemorySegment segment) {
        return SetClientSite.ofAddress(SetClientSite$get(segment));
    }
    static final FunctionDescriptor GetClientSite$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetClientSite$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetClientSite$FUNC, false
    );
    public interface GetClientSite {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(GetClientSite fi) {
            return RuntimeHelper.upcallStub(GetClientSite.class, fi, IOleObjectVtbl.GetClientSite$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetClientSite fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetClientSite.class, fi, IOleObjectVtbl.GetClientSite$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetClientSite ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IOleObjectVtbl.GetClientSite$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetClientSite$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetClientSite")));
    public static VarHandle GetClientSite$VH() {
        return IOleObjectVtbl.GetClientSite$VH;
    }
    public static MemoryAddress GetClientSite$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetClientSite$VH.get(seg);
    }
    public static void GetClientSite$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetClientSite$VH.set(seg, x);
    }
    public static MemoryAddress GetClientSite$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetClientSite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetClientSite$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetClientSite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetClientSite GetClientSite (MemorySegment segment) {
        return GetClientSite.ofAddress(GetClientSite$get(segment));
    }
    static final FunctionDescriptor SetHostNames$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle SetHostNames$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.SetHostNames$FUNC, false
    );
    public interface SetHostNames {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(SetHostNames fi) {
            return RuntimeHelper.upcallStub(SetHostNames.class, fi, IOleObjectVtbl.SetHostNames$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(SetHostNames fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(SetHostNames.class, fi, IOleObjectVtbl.SetHostNames$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static SetHostNames ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetHostNames$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetHostNames$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SetHostNames")));
    public static VarHandle SetHostNames$VH() {
        return IOleObjectVtbl.SetHostNames$VH;
    }
    public static MemoryAddress SetHostNames$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetHostNames$VH.get(seg);
    }
    public static void SetHostNames$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetHostNames$VH.set(seg, x);
    }
    public static MemoryAddress SetHostNames$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetHostNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetHostNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetHostNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetHostNames SetHostNames (MemorySegment segment) {
        return SetHostNames.ofAddress(SetHostNames$get(segment));
    }
    static final FunctionDescriptor Close$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG
    );
    static final MethodHandle Close$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;I)I",
        IOleObjectVtbl.Close$FUNC, false
    );
    public interface Close {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static MemoryAddress allocate(Close fi) {
            return RuntimeHelper.upcallStub(Close.class, fi, IOleObjectVtbl.Close$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I");
        }
        static MemoryAddress allocate(Close fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(Close.class, fi, IOleObjectVtbl.Close$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static Close ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)IOleObjectVtbl.Close$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Close$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("Close")));
    public static VarHandle Close$VH() {
        return IOleObjectVtbl.Close$VH;
    }
    public static MemoryAddress Close$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Close$VH.get(seg);
    }
    public static void Close$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Close$VH.set(seg, x);
    }
    public static MemoryAddress Close$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Close$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Close$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Close$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Close Close (MemorySegment segment) {
        return Close.ofAddress(Close$get(segment));
    }
    static final FunctionDescriptor SetMoniker$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle SetMoniker$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.SetMoniker$FUNC, false
    );
    public interface SetMoniker {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(SetMoniker fi) {
            return RuntimeHelper.upcallStub(SetMoniker.class, fi, IOleObjectVtbl.SetMoniker$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(SetMoniker fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(SetMoniker.class, fi, IOleObjectVtbl.SetMoniker$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static SetMoniker ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetMoniker$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetMoniker$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SetMoniker")));
    public static VarHandle SetMoniker$VH() {
        return IOleObjectVtbl.SetMoniker$VH;
    }
    public static MemoryAddress SetMoniker$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetMoniker$VH.get(seg);
    }
    public static void SetMoniker$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetMoniker$VH.set(seg, x);
    }
    public static MemoryAddress SetMoniker$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetMoniker$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetMoniker SetMoniker (MemorySegment segment) {
        return SetMoniker.ofAddress(SetMoniker$get(segment));
    }
    static final FunctionDescriptor GetMoniker$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle GetMoniker$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetMoniker$FUNC, false
    );
    public interface GetMoniker {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2, jdk.incubator.foreign.MemoryAddress x3);
        static MemoryAddress allocate(GetMoniker fi) {
            return RuntimeHelper.upcallStub(GetMoniker.class, fi, IOleObjectVtbl.GetMoniker$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetMoniker fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetMoniker.class, fi, IOleObjectVtbl.GetMoniker$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetMoniker ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2, jdk.incubator.foreign.MemoryAddress x3) -> {
                try {
                    return (int)IOleObjectVtbl.GetMoniker$MH.invokeExact((Addressable)addr, x0, x1, x2, x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMoniker$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetMoniker")));
    public static VarHandle GetMoniker$VH() {
        return IOleObjectVtbl.GetMoniker$VH;
    }
    public static MemoryAddress GetMoniker$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetMoniker$VH.get(seg);
    }
    public static void GetMoniker$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetMoniker$VH.set(seg, x);
    }
    public static MemoryAddress GetMoniker$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMoniker$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMoniker GetMoniker (MemorySegment segment) {
        return GetMoniker.ofAddress(GetMoniker$get(segment));
    }
    static final FunctionDescriptor InitFromData$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_INT,
        C_LONG
    );
    static final MethodHandle InitFromData$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;II)I",
        IOleObjectVtbl.InitFromData$FUNC, false
    );
    public interface InitFromData {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, int x3);
        static MemoryAddress allocate(InitFromData fi) {
            return RuntimeHelper.upcallStub(InitFromData.class, fi, IOleObjectVtbl.InitFromData$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;II)I");
        }
        static MemoryAddress allocate(InitFromData fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(InitFromData.class, fi, IOleObjectVtbl.InitFromData$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;II)I", scope);
        }
        static InitFromData ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, int x3) -> {
                try {
                    return (int)IOleObjectVtbl.InitFromData$MH.invokeExact((Addressable)addr, x0, x1, x2, x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle InitFromData$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("InitFromData")));
    public static VarHandle InitFromData$VH() {
        return IOleObjectVtbl.InitFromData$VH;
    }
    public static MemoryAddress InitFromData$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.InitFromData$VH.get(seg);
    }
    public static void InitFromData$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.InitFromData$VH.set(seg, x);
    }
    public static MemoryAddress InitFromData$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.InitFromData$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void InitFromData$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.InitFromData$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static InitFromData InitFromData (MemorySegment segment) {
        return InitFromData.ofAddress(InitFromData$get(segment));
    }
    static final FunctionDescriptor GetClipboardData$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle GetClipboardData$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetClipboardData$FUNC, false
    );
    public interface GetClipboardData {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(GetClipboardData fi) {
            return RuntimeHelper.upcallStub(GetClipboardData.class, fi, IOleObjectVtbl.GetClipboardData$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetClipboardData fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetClipboardData.class, fi, IOleObjectVtbl.GetClipboardData$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetClipboardData ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetClipboardData$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetClipboardData$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetClipboardData")));
    public static VarHandle GetClipboardData$VH() {
        return IOleObjectVtbl.GetClipboardData$VH;
    }
    public static MemoryAddress GetClipboardData$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetClipboardData$VH.get(seg);
    }
    public static void GetClipboardData$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetClipboardData$VH.set(seg, x);
    }
    public static MemoryAddress GetClipboardData$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetClipboardData$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetClipboardData$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetClipboardData$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetClipboardData GetClipboardData (MemorySegment segment) {
        return GetClipboardData.ofAddress(GetClipboardData$get(segment));
    }
    static final FunctionDescriptor DoVerb$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER,
        C_POINTER,
        C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle DoVerb$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.DoVerb$FUNC, false
    );
    public interface DoVerb {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, int x4, jdk.incubator.foreign.MemoryAddress x5, jdk.incubator.foreign.MemoryAddress x6);
        static MemoryAddress allocate(DoVerb fi) {
            return RuntimeHelper.upcallStub(DoVerb.class, fi, IOleObjectVtbl.DoVerb$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(DoVerb fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(DoVerb.class, fi, IOleObjectVtbl.DoVerb$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static DoVerb ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, int x4, jdk.incubator.foreign.MemoryAddress x5, jdk.incubator.foreign.MemoryAddress x6) -> {
                try {
                    return (int)IOleObjectVtbl.DoVerb$MH.invokeExact((Addressable)addr, x0, x1, x2, x3, x4, x5, x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DoVerb$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("DoVerb")));
    public static VarHandle DoVerb$VH() {
        return IOleObjectVtbl.DoVerb$VH;
    }
    public static MemoryAddress DoVerb$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.DoVerb$VH.get(seg);
    }
    public static void DoVerb$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.DoVerb$VH.set(seg, x);
    }
    public static MemoryAddress DoVerb$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.DoVerb$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DoVerb$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.DoVerb$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DoVerb DoVerb (MemorySegment segment) {
        return DoVerb.ofAddress(DoVerb$get(segment));
    }
    static final FunctionDescriptor EnumVerbs$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle EnumVerbs$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.EnumVerbs$FUNC, false
    );
    public interface EnumVerbs {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(EnumVerbs fi) {
            return RuntimeHelper.upcallStub(EnumVerbs.class, fi, IOleObjectVtbl.EnumVerbs$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(EnumVerbs fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(EnumVerbs.class, fi, IOleObjectVtbl.EnumVerbs$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static EnumVerbs ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IOleObjectVtbl.EnumVerbs$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnumVerbs$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("EnumVerbs")));
    public static VarHandle EnumVerbs$VH() {
        return IOleObjectVtbl.EnumVerbs$VH;
    }
    public static MemoryAddress EnumVerbs$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.EnumVerbs$VH.get(seg);
    }
    public static void EnumVerbs$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.EnumVerbs$VH.set(seg, x);
    }
    public static MemoryAddress EnumVerbs$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.EnumVerbs$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnumVerbs$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.EnumVerbs$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnumVerbs EnumVerbs (MemorySegment segment) {
        return EnumVerbs.ofAddress(EnumVerbs$get(segment));
    }
    static final FunctionDescriptor Update$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER
    );
    static final MethodHandle Update$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.Update$FUNC, false
    );
    public interface Update {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(Update fi) {
            return RuntimeHelper.upcallStub(Update.class, fi, IOleObjectVtbl.Update$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(Update fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(Update.class, fi, IOleObjectVtbl.Update$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static Update ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)IOleObjectVtbl.Update$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Update$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("Update")));
    public static VarHandle Update$VH() {
        return IOleObjectVtbl.Update$VH;
    }
    public static MemoryAddress Update$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Update$VH.get(seg);
    }
    public static void Update$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Update$VH.set(seg, x);
    }
    public static MemoryAddress Update$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Update$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Update$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Update$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Update Update (MemorySegment segment) {
        return Update.ofAddress(Update$get(segment));
    }
    static final FunctionDescriptor IsUpToDate$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER
    );
    static final MethodHandle IsUpToDate$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.IsUpToDate$FUNC, false
    );
    public interface IsUpToDate {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(IsUpToDate fi) {
            return RuntimeHelper.upcallStub(IsUpToDate.class, fi, IOleObjectVtbl.IsUpToDate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(IsUpToDate fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(IsUpToDate.class, fi, IOleObjectVtbl.IsUpToDate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static IsUpToDate ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)IOleObjectVtbl.IsUpToDate$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsUpToDate$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("IsUpToDate")));
    public static VarHandle IsUpToDate$VH() {
        return IOleObjectVtbl.IsUpToDate$VH;
    }
    public static MemoryAddress IsUpToDate$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.IsUpToDate$VH.get(seg);
    }
    public static void IsUpToDate$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.IsUpToDate$VH.set(seg, x);
    }
    public static MemoryAddress IsUpToDate$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.IsUpToDate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsUpToDate$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.IsUpToDate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsUpToDate IsUpToDate (MemorySegment segment) {
        return IsUpToDate.ofAddress(IsUpToDate$get(segment));
    }
    static final FunctionDescriptor GetUserClassID$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetUserClassID$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetUserClassID$FUNC, false
    );
    public interface GetUserClassID {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(GetUserClassID fi) {
            return RuntimeHelper.upcallStub(GetUserClassID.class, fi, IOleObjectVtbl.GetUserClassID$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetUserClassID fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetUserClassID.class, fi, IOleObjectVtbl.GetUserClassID$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetUserClassID ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IOleObjectVtbl.GetUserClassID$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserClassID$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetUserClassID")));
    public static VarHandle GetUserClassID$VH() {
        return IOleObjectVtbl.GetUserClassID$VH;
    }
    public static MemoryAddress GetUserClassID$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetUserClassID$VH.get(seg);
    }
    public static void GetUserClassID$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetUserClassID$VH.set(seg, x);
    }
    public static MemoryAddress GetUserClassID$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetUserClassID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserClassID$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetUserClassID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserClassID GetUserClassID (MemorySegment segment) {
        return GetUserClassID.ofAddress(GetUserClassID$get(segment));
    }
    static final FunctionDescriptor GetUserType$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle GetUserType$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetUserType$FUNC, false
    );
    public interface GetUserType {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(GetUserType fi) {
            return RuntimeHelper.upcallStub(GetUserType.class, fi, IOleObjectVtbl.GetUserType$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetUserType fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetUserType.class, fi, IOleObjectVtbl.GetUserType$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetUserType ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetUserType$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserType$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetUserType")));
    public static VarHandle GetUserType$VH() {
        return IOleObjectVtbl.GetUserType$VH;
    }
    public static MemoryAddress GetUserType$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetUserType$VH.get(seg);
    }
    public static void GetUserType$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetUserType$VH.set(seg, x);
    }
    public static MemoryAddress GetUserType$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetUserType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserType$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetUserType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserType GetUserType (MemorySegment segment) {
        return GetUserType.ofAddress(GetUserType$get(segment));
    }
    static final FunctionDescriptor SetExtent$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle SetExtent$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.SetExtent$FUNC, false
    );
    public interface SetExtent {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(SetExtent fi) {
            return RuntimeHelper.upcallStub(SetExtent.class, fi, IOleObjectVtbl.SetExtent$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(SetExtent fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(SetExtent.class, fi, IOleObjectVtbl.SetExtent$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static SetExtent ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetExtent$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetExtent$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SetExtent")));
    public static VarHandle SetExtent$VH() {
        return IOleObjectVtbl.SetExtent$VH;
    }
    public static MemoryAddress SetExtent$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetExtent$VH.get(seg);
    }
    public static void SetExtent$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetExtent$VH.set(seg, x);
    }
    public static MemoryAddress SetExtent$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetExtent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetExtent$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetExtent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetExtent SetExtent (MemorySegment segment) {
        return SetExtent.ofAddress(SetExtent$get(segment));
    }
    static final FunctionDescriptor GetExtent$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle GetExtent$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetExtent$FUNC, false
    );
    public interface GetExtent {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(GetExtent fi) {
            return RuntimeHelper.upcallStub(GetExtent.class, fi, IOleObjectVtbl.GetExtent$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetExtent fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetExtent.class, fi, IOleObjectVtbl.GetExtent$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetExtent ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetExtent$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetExtent$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetExtent")));
    public static VarHandle GetExtent$VH() {
        return IOleObjectVtbl.GetExtent$VH;
    }
    public static MemoryAddress GetExtent$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetExtent$VH.get(seg);
    }
    public static void GetExtent$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetExtent$VH.set(seg, x);
    }
    public static MemoryAddress GetExtent$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetExtent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetExtent$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetExtent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetExtent GetExtent (MemorySegment segment) {
        return GetExtent.ofAddress(GetExtent$get(segment));
    }
    static final FunctionDescriptor Advise$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle Advise$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.Advise$FUNC, false
    );
    public interface Advise {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(Advise fi) {
            return RuntimeHelper.upcallStub(Advise.class, fi, IOleObjectVtbl.Advise$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(Advise fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(Advise.class, fi, IOleObjectVtbl.Advise$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static Advise ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.Advise$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Advise$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("Advise")));
    public static VarHandle Advise$VH() {
        return IOleObjectVtbl.Advise$VH;
    }
    public static MemoryAddress Advise$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Advise$VH.get(seg);
    }
    public static void Advise$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Advise$VH.set(seg, x);
    }
    public static MemoryAddress Advise$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Advise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Advise$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Advise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Advise Advise (MemorySegment segment) {
        return Advise.ofAddress(Advise$get(segment));
    }
    static final FunctionDescriptor Unadvise$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG
    );
    static final MethodHandle Unadvise$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;I)I",
        IOleObjectVtbl.Unadvise$FUNC, false
    );
    public interface Unadvise {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static MemoryAddress allocate(Unadvise fi) {
            return RuntimeHelper.upcallStub(Unadvise.class, fi, IOleObjectVtbl.Unadvise$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I");
        }
        static MemoryAddress allocate(Unadvise fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(Unadvise.class, fi, IOleObjectVtbl.Unadvise$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static Unadvise ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)IOleObjectVtbl.Unadvise$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Unadvise$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("Unadvise")));
    public static VarHandle Unadvise$VH() {
        return IOleObjectVtbl.Unadvise$VH;
    }
    public static MemoryAddress Unadvise$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Unadvise$VH.get(seg);
    }
    public static void Unadvise$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.Unadvise$VH.set(seg, x);
    }
    public static MemoryAddress Unadvise$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.Unadvise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Unadvise$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.Unadvise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Unadvise Unadvise (MemorySegment segment) {
        return Unadvise.ofAddress(Unadvise$get(segment));
    }
    static final FunctionDescriptor EnumAdvise$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle EnumAdvise$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.EnumAdvise$FUNC, false
    );
    public interface EnumAdvise {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(EnumAdvise fi) {
            return RuntimeHelper.upcallStub(EnumAdvise.class, fi, IOleObjectVtbl.EnumAdvise$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(EnumAdvise fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(EnumAdvise.class, fi, IOleObjectVtbl.EnumAdvise$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static EnumAdvise ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IOleObjectVtbl.EnumAdvise$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnumAdvise$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("EnumAdvise")));
    public static VarHandle EnumAdvise$VH() {
        return IOleObjectVtbl.EnumAdvise$VH;
    }
    public static MemoryAddress EnumAdvise$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.EnumAdvise$VH.get(seg);
    }
    public static void EnumAdvise$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.EnumAdvise$VH.set(seg, x);
    }
    public static MemoryAddress EnumAdvise$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.EnumAdvise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnumAdvise$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.EnumAdvise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnumAdvise EnumAdvise (MemorySegment segment) {
        return EnumAdvise.ofAddress(EnumAdvise$get(segment));
    }
    static final FunctionDescriptor GetMiscStatus$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER
    );
    static final MethodHandle GetMiscStatus$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.GetMiscStatus$FUNC, false
    );
    public interface GetMiscStatus {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(GetMiscStatus fi) {
            return RuntimeHelper.upcallStub(GetMiscStatus.class, fi, IOleObjectVtbl.GetMiscStatus$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetMiscStatus fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetMiscStatus.class, fi, IOleObjectVtbl.GetMiscStatus$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetMiscStatus ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetMiscStatus$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMiscStatus$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetMiscStatus")));
    public static VarHandle GetMiscStatus$VH() {
        return IOleObjectVtbl.GetMiscStatus$VH;
    }
    public static MemoryAddress GetMiscStatus$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetMiscStatus$VH.get(seg);
    }
    public static void GetMiscStatus$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.GetMiscStatus$VH.set(seg, x);
    }
    public static MemoryAddress GetMiscStatus$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.GetMiscStatus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMiscStatus$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.GetMiscStatus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMiscStatus GetMiscStatus (MemorySegment segment) {
        return GetMiscStatus.ofAddress(GetMiscStatus$get(segment));
    }
    static final FunctionDescriptor SetColorScheme$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle SetColorScheme$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IOleObjectVtbl.SetColorScheme$FUNC, false
    );
    public interface SetColorScheme {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(SetColorScheme fi) {
            return RuntimeHelper.upcallStub(SetColorScheme.class, fi, IOleObjectVtbl.SetColorScheme$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(SetColorScheme fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(SetColorScheme.class, fi, IOleObjectVtbl.SetColorScheme$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static SetColorScheme ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IOleObjectVtbl.SetColorScheme$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetColorScheme$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("SetColorScheme")));
    public static VarHandle SetColorScheme$VH() {
        return IOleObjectVtbl.SetColorScheme$VH;
    }
    public static MemoryAddress SetColorScheme$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetColorScheme$VH.get(seg);
    }
    public static void SetColorScheme$set( MemorySegment seg, MemoryAddress x) {
        IOleObjectVtbl.SetColorScheme$VH.set(seg, x);
    }
    public static MemoryAddress SetColorScheme$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IOleObjectVtbl.SetColorScheme$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetColorScheme$set(MemorySegment seg, long index, MemoryAddress x) {
        IOleObjectVtbl.SetColorScheme$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetColorScheme SetColorScheme (MemorySegment segment) {
        return SetColorScheme.ofAddress(SetColorScheme$get(segment));
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.ofScope(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


