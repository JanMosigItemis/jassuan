// Generated by jextract

package de.itemis.mosig.jassuan;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.CLinker.*;
public class IRecordInfoVtbl {

    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(
        C_POINTER.withName("QueryInterface"),
        C_POINTER.withName("AddRef"),
        C_POINTER.withName("Release"),
        C_POINTER.withName("RecordInit"),
        C_POINTER.withName("RecordClear"),
        C_POINTER.withName("RecordCopy"),
        C_POINTER.withName("GetGuid"),
        C_POINTER.withName("GetName"),
        C_POINTER.withName("GetSize"),
        C_POINTER.withName("GetTypeInfo"),
        C_POINTER.withName("GetField"),
        C_POINTER.withName("GetFieldNoCopy"),
        C_POINTER.withName("PutField"),
        C_POINTER.withName("PutFieldNoCopy"),
        C_POINTER.withName("GetFieldNames"),
        C_POINTER.withName("IsMatchingType"),
        C_POINTER.withName("RecordCreate"),
        C_POINTER.withName("RecordCreateCopy"),
        C_POINTER.withName("RecordDestroy")
    ).withName("IRecordInfoVtbl");
    public static MemoryLayout $LAYOUT() {
        return IRecordInfoVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.QueryInterface$FUNC, false
    );
    public interface QueryInterface {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(QueryInterface fi) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IRecordInfoVtbl.QueryInterface$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(QueryInterface fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IRecordInfoVtbl.QueryInterface$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static QueryInterface ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IRecordInfoVtbl.QueryInterface$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("QueryInterface")));
    public static VarHandle QueryInterface$VH() {
        return IRecordInfoVtbl.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment) {
        return QueryInterface.ofAddress(QueryInterface$get(segment));
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.AddRef$FUNC, false
    );
    public interface AddRef {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(AddRef fi) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IRecordInfoVtbl.AddRef$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(AddRef fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IRecordInfoVtbl.AddRef$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static AddRef ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)IRecordInfoVtbl.AddRef$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("AddRef")));
    public static VarHandle AddRef$VH() {
        return IRecordInfoVtbl.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment) {
        return AddRef.ofAddress(AddRef$get(segment));
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.Release$FUNC, false
    );
    public interface Release {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(Release fi) {
            return RuntimeHelper.upcallStub(Release.class, fi, IRecordInfoVtbl.Release$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(Release fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(Release.class, fi, IRecordInfoVtbl.Release$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static Release ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)IRecordInfoVtbl.Release$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("Release")));
    public static VarHandle Release$VH() {
        return IRecordInfoVtbl.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment) {
        return Release.ofAddress(Release$get(segment));
    }
    static final FunctionDescriptor RecordInit$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle RecordInit$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.RecordInit$FUNC, false
    );
    public interface RecordInit {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(RecordInit fi) {
            return RuntimeHelper.upcallStub(RecordInit.class, fi, IRecordInfoVtbl.RecordInit$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(RecordInit fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(RecordInit.class, fi, IRecordInfoVtbl.RecordInit$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static RecordInit ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordInit$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordInit$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("RecordInit")));
    public static VarHandle RecordInit$VH() {
        return IRecordInfoVtbl.RecordInit$VH;
    }
    public static MemoryAddress RecordInit$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordInit$VH.get(seg);
    }
    public static void RecordInit$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordInit$VH.set(seg, x);
    }
    public static MemoryAddress RecordInit$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordInit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordInit$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordInit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordInit RecordInit (MemorySegment segment) {
        return RecordInit.ofAddress(RecordInit$get(segment));
    }
    static final FunctionDescriptor RecordClear$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle RecordClear$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.RecordClear$FUNC, false
    );
    public interface RecordClear {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(RecordClear fi) {
            return RuntimeHelper.upcallStub(RecordClear.class, fi, IRecordInfoVtbl.RecordClear$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(RecordClear fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(RecordClear.class, fi, IRecordInfoVtbl.RecordClear$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static RecordClear ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordClear$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordClear$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("RecordClear")));
    public static VarHandle RecordClear$VH() {
        return IRecordInfoVtbl.RecordClear$VH;
    }
    public static MemoryAddress RecordClear$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordClear$VH.get(seg);
    }
    public static void RecordClear$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordClear$VH.set(seg, x);
    }
    public static MemoryAddress RecordClear$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordClear$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordClear$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordClear$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordClear RecordClear (MemorySegment segment) {
        return RecordClear.ofAddress(RecordClear$get(segment));
    }
    static final FunctionDescriptor RecordCopy$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle RecordCopy$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.RecordCopy$FUNC, false
    );
    public interface RecordCopy {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(RecordCopy fi) {
            return RuntimeHelper.upcallStub(RecordCopy.class, fi, IRecordInfoVtbl.RecordCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(RecordCopy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(RecordCopy.class, fi, IRecordInfoVtbl.RecordCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static RecordCopy ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordCopy$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCopy$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("RecordCopy")));
    public static VarHandle RecordCopy$VH() {
        return IRecordInfoVtbl.RecordCopy$VH;
    }
    public static MemoryAddress RecordCopy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCopy$VH.get(seg);
    }
    public static void RecordCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordCopy$VH.set(seg, x);
    }
    public static MemoryAddress RecordCopy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCopy RecordCopy (MemorySegment segment) {
        return RecordCopy.ofAddress(RecordCopy$get(segment));
    }
    static final FunctionDescriptor GetGuid$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetGuid$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetGuid$FUNC, false
    );
    public interface GetGuid {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(GetGuid fi) {
            return RuntimeHelper.upcallStub(GetGuid.class, fi, IRecordInfoVtbl.GetGuid$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetGuid fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetGuid.class, fi, IRecordInfoVtbl.GetGuid$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetGuid ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetGuid$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetGuid$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetGuid")));
    public static VarHandle GetGuid$VH() {
        return IRecordInfoVtbl.GetGuid$VH;
    }
    public static MemoryAddress GetGuid$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetGuid$VH.get(seg);
    }
    public static void GetGuid$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetGuid$VH.set(seg, x);
    }
    public static MemoryAddress GetGuid$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetGuid$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetGuid$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetGuid$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetGuid GetGuid (MemorySegment segment) {
        return GetGuid.ofAddress(GetGuid$get(segment));
    }
    static final FunctionDescriptor GetName$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetName$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetName$FUNC, false
    );
    public interface GetName {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(GetName fi) {
            return RuntimeHelper.upcallStub(GetName.class, fi, IRecordInfoVtbl.GetName$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetName fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetName.class, fi, IRecordInfoVtbl.GetName$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetName ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetName$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetName$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetName")));
    public static VarHandle GetName$VH() {
        return IRecordInfoVtbl.GetName$VH;
    }
    public static MemoryAddress GetName$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetName$VH.get(seg);
    }
    public static void GetName$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetName$VH.set(seg, x);
    }
    public static MemoryAddress GetName$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetName$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetName GetName (MemorySegment segment) {
        return GetName.ofAddress(GetName$get(segment));
    }
    static final FunctionDescriptor GetSize$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetSize$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetSize$FUNC, false
    );
    public interface GetSize {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(GetSize fi) {
            return RuntimeHelper.upcallStub(GetSize.class, fi, IRecordInfoVtbl.GetSize$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetSize fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetSize.class, fi, IRecordInfoVtbl.GetSize$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetSize ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetSize$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSize$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetSize")));
    public static VarHandle GetSize$VH() {
        return IRecordInfoVtbl.GetSize$VH;
    }
    public static MemoryAddress GetSize$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetSize$VH.get(seg);
    }
    public static void GetSize$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetSize$VH.set(seg, x);
    }
    public static MemoryAddress GetSize$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetSize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSize$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetSize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSize GetSize (MemorySegment segment) {
        return GetSize.ofAddress(GetSize$get(segment));
    }
    static final FunctionDescriptor GetTypeInfo$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetTypeInfo$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetTypeInfo$FUNC, false
    );
    public interface GetTypeInfo {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(GetTypeInfo fi) {
            return RuntimeHelper.upcallStub(GetTypeInfo.class, fi, IRecordInfoVtbl.GetTypeInfo$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetTypeInfo fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetTypeInfo.class, fi, IRecordInfoVtbl.GetTypeInfo$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetTypeInfo ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetTypeInfo$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetTypeInfo$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetTypeInfo")));
    public static VarHandle GetTypeInfo$VH() {
        return IRecordInfoVtbl.GetTypeInfo$VH;
    }
    public static MemoryAddress GetTypeInfo$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetTypeInfo$VH.get(seg);
    }
    public static void GetTypeInfo$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetTypeInfo$VH.set(seg, x);
    }
    public static MemoryAddress GetTypeInfo$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetTypeInfo$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetTypeInfo$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetTypeInfo$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetTypeInfo GetTypeInfo (MemorySegment segment) {
        return GetTypeInfo.ofAddress(GetTypeInfo$get(segment));
    }
    static final FunctionDescriptor GetField$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetField$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetField$FUNC, false
    );
    public interface GetField {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3);
        static MemoryAddress allocate(GetField fi) {
            return RuntimeHelper.upcallStub(GetField.class, fi, IRecordInfoVtbl.GetField$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetField fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetField.class, fi, IRecordInfoVtbl.GetField$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetField ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3) -> {
                try {
                    return (int)IRecordInfoVtbl.GetField$MH.invokeExact((Addressable)addr, x0, x1, x2, x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetField$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetField")));
    public static VarHandle GetField$VH() {
        return IRecordInfoVtbl.GetField$VH;
    }
    public static MemoryAddress GetField$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetField$VH.get(seg);
    }
    public static void GetField$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetField$VH.set(seg, x);
    }
    public static MemoryAddress GetField$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetField$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetField GetField (MemorySegment segment) {
        return GetField.ofAddress(GetField$get(segment));
    }
    static final FunctionDescriptor GetFieldNoCopy$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetFieldNoCopy$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetFieldNoCopy$FUNC, false
    );
    public interface GetFieldNoCopy {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4);
        static MemoryAddress allocate(GetFieldNoCopy fi) {
            return RuntimeHelper.upcallStub(GetFieldNoCopy.class, fi, IRecordInfoVtbl.GetFieldNoCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetFieldNoCopy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetFieldNoCopy.class, fi, IRecordInfoVtbl.GetFieldNoCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetFieldNoCopy ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)IRecordInfoVtbl.GetFieldNoCopy$MH.invokeExact((Addressable)addr, x0, x1, x2, x3, x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldNoCopy$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetFieldNoCopy")));
    public static VarHandle GetFieldNoCopy$VH() {
        return IRecordInfoVtbl.GetFieldNoCopy$VH;
    }
    public static MemoryAddress GetFieldNoCopy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNoCopy$VH.get(seg);
    }
    public static void GetFieldNoCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNoCopy$VH.set(seg, x);
    }
    public static MemoryAddress GetFieldNoCopy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNoCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldNoCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNoCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldNoCopy GetFieldNoCopy (MemorySegment segment) {
        return GetFieldNoCopy.ofAddress(GetFieldNoCopy$get(segment));
    }
    static final FunctionDescriptor PutField$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle PutField$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.PutField$FUNC, false
    );
    public interface PutField {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4);
        static MemoryAddress allocate(PutField fi) {
            return RuntimeHelper.upcallStub(PutField.class, fi, IRecordInfoVtbl.PutField$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(PutField fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(PutField.class, fi, IRecordInfoVtbl.PutField$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static PutField ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)IRecordInfoVtbl.PutField$MH.invokeExact((Addressable)addr, x0, x1, x2, x3, x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PutField$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("PutField")));
    public static VarHandle PutField$VH() {
        return IRecordInfoVtbl.PutField$VH;
    }
    public static MemoryAddress PutField$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.PutField$VH.get(seg);
    }
    public static void PutField$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.PutField$VH.set(seg, x);
    }
    public static MemoryAddress PutField$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.PutField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PutField$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.PutField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PutField PutField (MemorySegment segment) {
        return PutField.ofAddress(PutField$get(segment));
    }
    static final FunctionDescriptor PutFieldNoCopy$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle PutFieldNoCopy$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.PutFieldNoCopy$FUNC, false
    );
    public interface PutFieldNoCopy {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4);
        static MemoryAddress allocate(PutFieldNoCopy fi) {
            return RuntimeHelper.upcallStub(PutFieldNoCopy.class, fi, IRecordInfoVtbl.PutFieldNoCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(PutFieldNoCopy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(PutFieldNoCopy.class, fi, IRecordInfoVtbl.PutFieldNoCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static PutFieldNoCopy ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)IRecordInfoVtbl.PutFieldNoCopy$MH.invokeExact((Addressable)addr, x0, x1, x2, x3, x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PutFieldNoCopy$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("PutFieldNoCopy")));
    public static VarHandle PutFieldNoCopy$VH() {
        return IRecordInfoVtbl.PutFieldNoCopy$VH;
    }
    public static MemoryAddress PutFieldNoCopy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.PutFieldNoCopy$VH.get(seg);
    }
    public static void PutFieldNoCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.PutFieldNoCopy$VH.set(seg, x);
    }
    public static MemoryAddress PutFieldNoCopy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.PutFieldNoCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PutFieldNoCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.PutFieldNoCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PutFieldNoCopy PutFieldNoCopy (MemorySegment segment) {
        return PutFieldNoCopy.ofAddress(PutFieldNoCopy$get(segment));
    }
    static final FunctionDescriptor GetFieldNames$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle GetFieldNames$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.GetFieldNames$FUNC, false
    );
    public interface GetFieldNames {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(GetFieldNames fi) {
            return RuntimeHelper.upcallStub(GetFieldNames.class, fi, IRecordInfoVtbl.GetFieldNames$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(GetFieldNames fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(GetFieldNames.class, fi, IRecordInfoVtbl.GetFieldNames$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static GetFieldNames ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IRecordInfoVtbl.GetFieldNames$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldNames$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("GetFieldNames")));
    public static VarHandle GetFieldNames$VH() {
        return IRecordInfoVtbl.GetFieldNames$VH;
    }
    public static MemoryAddress GetFieldNames$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNames$VH.get(seg);
    }
    public static void GetFieldNames$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNames$VH.set(seg, x);
    }
    public static MemoryAddress GetFieldNames$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.GetFieldNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldNames$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.GetFieldNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldNames GetFieldNames (MemorySegment segment) {
        return GetFieldNames.ofAddress(GetFieldNames$get(segment));
    }
    static final FunctionDescriptor IsMatchingType$FUNC = FunctionDescriptor.of(C_INT,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle IsMatchingType$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.IsMatchingType$FUNC, false
    );
    public interface IsMatchingType {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(IsMatchingType fi) {
            return RuntimeHelper.upcallStub(IsMatchingType.class, fi, IRecordInfoVtbl.IsMatchingType$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(IsMatchingType fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(IsMatchingType.class, fi, IRecordInfoVtbl.IsMatchingType$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static IsMatchingType ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.IsMatchingType$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsMatchingType$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("IsMatchingType")));
    public static VarHandle IsMatchingType$VH() {
        return IRecordInfoVtbl.IsMatchingType$VH;
    }
    public static MemoryAddress IsMatchingType$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.IsMatchingType$VH.get(seg);
    }
    public static void IsMatchingType$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.IsMatchingType$VH.set(seg, x);
    }
    public static MemoryAddress IsMatchingType$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.IsMatchingType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsMatchingType$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.IsMatchingType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsMatchingType IsMatchingType (MemorySegment segment) {
        return IsMatchingType.ofAddress(IsMatchingType$get(segment));
    }
    static final FunctionDescriptor RecordCreate$FUNC = FunctionDescriptor.of(C_POINTER,
        C_POINTER
    );
    static final MethodHandle RecordCreate$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
        IRecordInfoVtbl.RecordCreate$FUNC, false
    );
    public interface RecordCreate {

        jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0);
        static MemoryAddress allocate(RecordCreate fi) {
            return RuntimeHelper.upcallStub(RecordCreate.class, fi, IRecordInfoVtbl.RecordCreate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;");
        }
        static MemoryAddress allocate(RecordCreate fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(RecordCreate.class, fi, IRecordInfoVtbl.RecordCreate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;", scope);
        }
        static RecordCreate ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreate$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCreate$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("RecordCreate")));
    public static VarHandle RecordCreate$VH() {
        return IRecordInfoVtbl.RecordCreate$VH;
    }
    public static MemoryAddress RecordCreate$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreate$VH.get(seg);
    }
    public static void RecordCreate$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreate$VH.set(seg, x);
    }
    public static MemoryAddress RecordCreate$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCreate$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCreate RecordCreate (MemorySegment segment) {
        return RecordCreate.ofAddress(RecordCreate$get(segment));
    }
    static final FunctionDescriptor RecordCreateCopy$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle RecordCreateCopy$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.RecordCreateCopy$FUNC, false
    );
    public interface RecordCreateCopy {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static MemoryAddress allocate(RecordCreateCopy fi) {
            return RuntimeHelper.upcallStub(RecordCreateCopy.class, fi, IRecordInfoVtbl.RecordCreateCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(RecordCreateCopy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(RecordCreateCopy.class, fi, IRecordInfoVtbl.RecordCreateCopy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static RecordCreateCopy ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordCreateCopy$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCreateCopy$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("RecordCreateCopy")));
    public static VarHandle RecordCreateCopy$VH() {
        return IRecordInfoVtbl.RecordCreateCopy$VH;
    }
    public static MemoryAddress RecordCreateCopy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreateCopy$VH.get(seg);
    }
    public static void RecordCreateCopy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreateCopy$VH.set(seg, x);
    }
    public static MemoryAddress RecordCreateCopy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordCreateCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCreateCopy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordCreateCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCreateCopy RecordCreateCopy (MemorySegment segment) {
        return RecordCreateCopy.ofAddress(RecordCreateCopy$get(segment));
    }
    static final FunctionDescriptor RecordDestroy$FUNC = FunctionDescriptor.of(C_LONG,
        C_POINTER,
        C_POINTER
    );
    static final MethodHandle RecordDestroy$MH = RuntimeHelper.downcallHandle(
        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
        IRecordInfoVtbl.RecordDestroy$FUNC, false
    );
    public interface RecordDestroy {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static MemoryAddress allocate(RecordDestroy fi) {
            return RuntimeHelper.upcallStub(RecordDestroy.class, fi, IRecordInfoVtbl.RecordDestroy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static MemoryAddress allocate(RecordDestroy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(RecordDestroy.class, fi, IRecordInfoVtbl.RecordDestroy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static RecordDestroy ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordDestroy$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordDestroy$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement("RecordDestroy")));
    public static VarHandle RecordDestroy$VH() {
        return IRecordInfoVtbl.RecordDestroy$VH;
    }
    public static MemoryAddress RecordDestroy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordDestroy$VH.get(seg);
    }
    public static void RecordDestroy$set( MemorySegment seg, MemoryAddress x) {
        IRecordInfoVtbl.RecordDestroy$VH.set(seg, x);
    }
    public static MemoryAddress RecordDestroy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)IRecordInfoVtbl.RecordDestroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordDestroy$set(MemorySegment seg, long index, MemoryAddress x) {
        IRecordInfoVtbl.RecordDestroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordDestroy RecordDestroy (MemorySegment segment) {
        return RecordDestroy.ofAddress(RecordDestroy$get(segment));
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.ofScope(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


